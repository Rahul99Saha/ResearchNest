# sql_and_nosql_solutions

---

## Login & Signup Queries

### 1. SQL Approach

#### SQL Table
```sql
CREATE TABLE Users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role ENUM('Student','Faculty','Admin') DEFAULT 'Student',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### Insert (Signup)
```sql
INSERT INTO Users (name, email, password_hash, role)
VALUES ('Alice', 'alice@example.com', 'hashed_password_here', 'Student');
```

#### Retrieve (Login)
```sql
SELECT user_id, name, email, role, password_hash
FROM Users
WHERE email = 'alice@example.com';
```

*(Password verification happens in backend using hashing, e.g. bcrypt.)*

---

### 2. MongoDB Approach

#### MongoDB Collection Structure
```javascript
db.users.insertOne({
  name: "Alice",
  email: "alice@example.com",
  passwordHash: "hashed_password_here",
  role: "Student",
  createdAt: new Date()
});
```

#### Insert (Signup)
```javascript
db.users.insertOne({
  name: "Alice",
  email: "alice@example.com",
  passwordHash: "hashed_password_here",
  role: "Student",
  createdAt: new Date()
});
```

#### Retrieve (Login)
```javascript
db.users.findOne({ email: "alice@example.com" });
```

---

### 3. Comparison (Login/Signup)

| Feature                | SQL                         | MongoDB                        |
|-------------------------|-----------------------------|--------------------------------|
| Schema                 | Strict (fixed columns)      | Flexible (document-based)      |
| Uniqueness Constraint  | UNIQUE constraint on email  | Must manually enforce (index)  |
| Authentication Queries | Straightforward `SELECT`    | Straightforward `findOne`      |
| Transactions           | Strong ACID compliance      | Eventual consistency possible  |
| Scaling                | Vertical (harder to scale)  | Horizontal (easier to scale)   |

---

### Recommendation for ResearchNest

- **SQL (MySQL/PostgreSQL)** is better for login and signup because:
  - Requires strict constraints (unique email, strong transactions).
  - Schema is stable (user data doesn’t change often).
  - ACID guarantees ensure reliability (no duplicate users).

- **MongoDB** is better for the **Progress Tracker** (hierarchical milestones, tasks, subtasks).

✅ **Hybrid approach** works best:
- Use **SQL** for Authentication & User Management.  
- Use **MongoDB** for Progress Tracker and hierarchical academic data.  

---

## Progress Tracker Queries

The Progress Tracker involves a deep, four-level hierarchy (Milestone → Stage → Task → Subtask).

---

### 1. SQL Approach

#### SQL Schemas (5 Tables)

| Table              | Purpose                         | Relationship                    |
|--------------------|---------------------------------|---------------------------------|
| ProgressInstances  | Links a student to their template | 1:1 with Users                  |
| Milestones         | Top-level item                  | FK to ProgressInstances         |
| Stages             | Child of Milestone              | FK to Milestones                |
| Tasks              | Child of Stage                  | FK to Stages                    |
| Subtasks           | Bottom-level item               | FK to Tasks                     |

#### Schema
```sql
CREATE TABLE ProgressInstances (
    instance_id INT PRIMARY KEY AUTO_INCREMENT,
    student_id INT NOT NULL,
    template_id INT,
    FOREIGN KEY (student_id) REFERENCES Users(user_id)
);

CREATE TABLE Milestones (
    milestone_id INT PRIMARY KEY AUTO_INCREMENT,
    instance_id INT NOT NULL,
    title VARCHAR(255) NOT NULL,
    status VARCHAR(50) DEFAULT 'Locked',
    FOREIGN KEY (instance_id) REFERENCES ProgressInstances(instance_id)
);

CREATE TABLE Stages (
    stage_id INT PRIMARY KEY AUTO_INCREMENT,
    milestone_id INT NOT NULL,
    title VARCHAR(255) NOT NULL,
    status VARCHAR(50) DEFAULT 'Locked',
    FOREIGN KEY (milestone_id) REFERENCES Milestones(milestone_id)
);

-- ... (Similar tables for Tasks and Subtasks)
```

#### Retrieve Full Tree
```sql
SELECT * 
FROM ProgressInstances pi 
JOIN Milestones m ON pi.instance_id = m.instance_id 
JOIN Stages s ON m.milestone_id = s.milestone_id 
-- ... requires up to 4–5 JOINs
WHERE pi.student_id = ?;
```

*(Complexity: High. Performance: slow due to multiple joins.)*

#### Update Status (Subtask)
```sql
UPDATE Subtasks 
SET status = 'Completed' 
WHERE subtask_id = ?;
```

*(Complexity: Low, single UPDATE.)*

#### Status Propagation
```sql
-- Stored Procedure (pseudocode)
IF all siblings Completed THEN
   UPDATE parent Task → Completed
   RECURSE to Stage → Milestone → Instance
END IF;
```

*(Complexity: Very High. Requires recursive logic in DB or backend.)*

---

### 2. MongoDB Approach

#### Mongo Schema
```javascript
{
  _id: ObjectId,
  studentId: ObjectId, // Reference to User
  milestones: [ 
    { 
      _id: ObjectId, status: '...', 
      stages: [ 
        { 
          _id: ObjectId, status: '...', 
          tasks: [ 
            { 
              _id: ObjectId, status: '...', 
              subtasks: [{ _id: ObjectId, status: '...' }] 
            } 
          ] 
        } 
      ] 
    } 
  ],
  audit: [ { when: Date, action: '...' } ]
}
```

#### Retrieve Full Tree
```javascript
db.ProgressInstance.findOne({ studentId: req.user._id });
```

*(Complexity: Single read operation. Fast.)*

#### Update Status (Subtask)
```javascript
const inst = await ProgressInstance.findOne({ studentId: userId });
setNodeStatusById(inst.milestones, subtaskId, 'Completed');
await inst.save();
```

#### Status Propagation
```javascript
const inst = await ProgressInstance.findOne({ studentId: userId });
propagateStatus(inst.milestones);
await inst.save();
```

*(Complexity: Low. Handled in app layer.)*

---

## Profile 

Profile Retrieval involves **self-referencing (Faculty)** 

---

### 1. SQL Approach

#### Retrieve Full Profile
```sql
SELECT 
    u.*, rp.*, ai.*, s.name AS Faculty_name
FROM Users u
JOIN ResearchProfiles rp ON u.user_id = rp.user_id
LEFT JOIN AcademicInfo ai ON u.user_id = ai.user_id
LEFT JOIN Users s ON rp.Faculty_id = s.user_id
WHERE u.user_id = ?;
```

---

### 2. MongoDB Approach

#### Retrieve Full Profile
```javascript
db.users.findOne({ _id: userId }).populate('researchProfile.Faculty');
```

---

### 3. Comparison (Profile Update)

| Feature              | SQL (Normalized)                                  | MongoDB (Embedded/Reference)                          |
|----------------------|--------------------------------------------------|-------------------------------------------------------|
| Data Locality        | Spread across 3–4 tables                         | High (embedded in User doc)                           |
| Retrieve Full Profile| 3–4 JOINs                                        | Single `findOne` with minimal `populate`              |

---

## Final Recommendation

- **SQL (MySQL/Postgres)** for:
  - Authentication  
  - User Management  

- **MongoDB** for:
  - Progress Tracker  
  - Profile Management (hierarchical, nested structures)  

✅ **MERN stack with hybrid SQL + NoSQL** is best for ResearchNest.  
- SQL ensures reliable authentication.  
- MongoDB ensures flexible, efficient handling of hierarchical and profile data.  
